webpackHotUpdate(0,{

/***/ "../../../../../../scripts/frontend/scrollTransformImage/index.js":
/*!******************************************************************************!*\
  !*** E:/Work/ehabana2/assets/scripts/frontend/scrollTransformImage/index.js ***!
  \******************************************************************************/
/*! dynamic exports provided */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n* demo.js\n* http://www.codrops.com\n*\n* Licensed under the MIT license.\n* http://www.opensource.org/licenses/mit-license.php\n* \n* Copyright 2019, Codrops\n* http://www.codrops.com\n*/\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n{\n    // helper functions\n    var MathUtils = {\n        // map number x from range [a, b] to [c, d]\n        map: function map(x, a, b, c, d) {\n            return (x - a) * (d - c) / (b - a) + c;\n        },\n        // linear interpolation\n        lerp: function lerp(a, b, n) {\n            return (1 - n) * a + n * b;\n        },\n        // Random float\n        getRandomFloat: function getRandomFloat(min, max) {\n            return (Math.random() * (max - min) + min).toFixed(2);\n        }\n    };\n\n    // body element\n    var body = document.body;\n\n    // calculate the viewport size\n    var winsize = void 0;\n    var calcWinsize = function calcWinsize() {\n        return winsize = { width: window.innerWidth, height: window.innerHeight };\n    };\n    calcWinsize();\n    // and recalculate on resize\n    window.addEventListener('resize', calcWinsize);\n\n    // scroll position\n    var docScroll = void 0;\n    // for scroll speed calculation\n    var lastScroll = void 0;\n    var scrollingSpeed = 0;\n    // scroll position update function\n    var getPageYScroll = function getPageYScroll() {\n        return docScroll = window.pageYOffset || document.documentElement.scrollTop;\n    };\n    window.addEventListener('scroll', getPageYScroll);\n\n    // Item\n\n    var Item = function () {\n        function Item(el) {\n            var _this = this;\n\n            _classCallCheck(this, Item);\n\n            // the .item element\n            this.DOM = { el: el };\n            console.log(this.DOM);\n            // the inner image\n            this.DOM.image = this.DOM.el.querySelector('img');\n            this.DOM.imageWrapper = this.DOM.image.parentNode;\n            //this.DOM.title = this.DOM.el.querySelector('.content__item-title');\n            this.renderedStyles = {\n                // here we define which property will change as we scroll the page and the item is inside the viewport\n                // in this case we will be:\n                // - scaling the inner image\n                // - translating the item's title\n                // we interpolate between the previous and current value to achieve a smooth effect\n                imageScale: {\n                    // interpolated value\n                    previous: 0,\n                    // current value\n                    current: 0,\n                    // amount to interpolate\n                    ease: 0.1,\n                    // current value setter\n                    setValue: function setValue() {\n                        var toValue = 1.5;\n                        var fromValue = 1;\n                        var val = MathUtils.map(_this.props.top - docScroll, winsize.height, -1 * _this.props.height, fromValue, toValue);\n                        return Math.max(Math.min(val, toValue), fromValue);\n                    }\n                }\n                /*\n                titleTranslationY: {\n                    previous: 0, \n                    current: 0, \n                    ease: 0.1,\n                    fromValue: Number(MathUtils.getRandomFloat(30,400)),\n                    setValue: () => {\n                        const fromValue = this.renderedStyles.titleTranslationY.fromValue;\n                        const toValue = -1*fromValue;\n                        const val = MathUtils.map(this.props.top - docScroll, winsize.height, -1 * this.props.height, fromValue, toValue);\n                        return fromValue < 0 ? Math.min(Math.max(val, fromValue), toValue) : Math.max(Math.min(val, fromValue), toValue);\n                    }\n                }\n                */\n            };\n            // gets the item's height and top (relative to the document)\n            this.getSize();\n            // set the initial values\n            this.update();\n            // use the IntersectionObserver API to check when the element is inside the viewport\n            // only then the element styles will be updated\n            this.observer = new IntersectionObserver(function (entries) {\n                entries.forEach(function (entry) {\n                    return _this.isVisible = entry.intersectionRatio > 0;\n                });\n            });\n            this.observer.observe(this.DOM.el);\n            // init/bind events\n            this.initEvents();\n        }\n\n        _createClass(Item, [{\n            key: 'update',\n            value: function update() {\n                // sets the initial value (no interpolation)\n                for (var key in this.renderedStyles) {\n                    this.renderedStyles[key].current = this.renderedStyles[key].previous = this.renderedStyles[key].setValue();\n                }\n                // apply changes/styles\n                this.layout();\n            }\n        }, {\n            key: 'getSize',\n            value: function getSize() {\n                var rect = this.DOM.el.getBoundingClientRect();\n                this.props = {\n                    // item's height\n                    height: rect.height,\n                    // offset top relative to the document\n                    top: docScroll + rect.top\n                };\n            }\n        }, {\n            key: 'initEvents',\n            value: function initEvents() {\n                var _this2 = this;\n\n                window.addEventListener('resize', function () {\n                    return _this2.resize();\n                });\n            }\n        }, {\n            key: 'resize',\n            value: function resize() {\n                // gets the item's height and top (relative to the document)\n                this.getSize();\n                // on resize reset sizes and update styles\n                this.update();\n            }\n        }, {\n            key: 'render',\n            value: function render() {\n                // update the current and interpolated values\n                for (var key in this.renderedStyles) {\n                    this.renderedStyles[key].current = this.renderedStyles[key].setValue();\n                    this.renderedStyles[key].previous = MathUtils.lerp(this.renderedStyles[key].previous, this.renderedStyles[key].current, this.renderedStyles[key].ease);\n                }\n\n                // and apply changes\n                this.layout();\n            }\n        }, {\n            key: 'layout',\n            value: function layout() {\n                console.log(\" scale the image..|\");\n                this.DOM.image.style.transform = 'scale3d(' + this.renderedStyles.imageScale.previous + ',' + this.renderedStyles.imageScale.previous + ',1)';\n                // translate the title\n                //  this.DOM.title.style.transform = `translate3d(0,${this.renderedStyles.titleTranslationY.previous}px,0)`;\n            }\n        }]);\n\n        return Item;\n    }();\n\n    // SmoothScroll\n\n\n    var SmoothScroll = function () {\n        function SmoothScroll() {\n            var _this3 = this;\n\n            _classCallCheck(this, SmoothScroll);\n\n            // the <main> element\n            this.DOM = { main: document.querySelector('body') };\n            // the scrollable element\n            // we translate this element when scrolling (y-axis)\n            this.DOM.scrollable = this.DOM.main.querySelector('main[data-scroll]');\n            // the items on the page\n            this.items = [];\n            this.DOM.content = this.DOM.main.querySelector('section');\n            [].concat(_toConsumableArray(this.DOM.content.querySelectorAll('.animated-img-container'))).forEach(function (item) {\n                return _this3.items.push(new Item(item));\n            });\n            // here we define which property will change as we scroll the page\n            // in this case we will be translating on the y-axis\n            // we interpolate between the previous and current value to achieve the smooth scrolling effect\n            this.renderedStyles = {\n                translationY: {\n                    // interpolated value\n                    previous: 0,\n                    // current value\n                    current: 0,\n                    // amount to interpolate\n                    ease: 0.1,\n                    // current value setter\n                    // in this case the value of the translation will be the same like the document scroll\n                    setValue: function setValue() {\n                        return docScroll;\n                    }\n                }\n            };\n            // set the body's height\n            this.setSize();\n            // set the initial values\n            this.update();\n            // the <main> element's style needs to be modified\n            this.style();\n            // init/bind events\n            this.initEvents();\n            // start the render loop\n            requestAnimationFrame(function () {\n                return _this3.render();\n            });\n        }\n\n        _createClass(SmoothScroll, [{\n            key: 'update',\n            value: function update() {\n                // sets the initial value (no interpolation) - translate the scroll value\n                for (var key in this.renderedStyles) {\n                    this.renderedStyles[key].current = this.renderedStyles[key].previous = this.renderedStyles[key].setValue();\n                }\n                // translate the scrollable element\n                this.layout();\n            }\n        }, {\n            key: 'layout',\n            value: function layout() {\n                this.DOM.scrollable.style.transform = 'translate3d(0,' + -1 * this.renderedStyles.translationY.previous + 'px,0)';\n            }\n        }, {\n            key: 'setSize',\n            value: function setSize() {\n                // set the heigh of the body in order to keep the scrollbar on the page\n                body.style.height = this.DOM.scrollable.scrollHeight + 'px';\n            }\n        }, {\n            key: 'style',\n            value: function style() {\n                // the <main> needs to \"stick\" to the screen and not scroll\n                // for that we set it to position fixed and overflow hidden \n                this.DOM.main.style.position = 'fixed';\n                this.DOM.main.style.width = this.DOM.main.style.height = '100%';\n                this.DOM.main.style.top = this.DOM.main.style.left = 0;\n                this.DOM.main.style.overflow = 'hidden';\n            }\n        }, {\n            key: 'initEvents',\n            value: function initEvents() {\n                var _this4 = this;\n\n                // on resize reset the body's height\n                window.addEventListener('resize', function () {\n                    return _this4.setSize();\n                });\n            }\n        }, {\n            key: 'render',\n            value: function render() {\n                var _this5 = this;\n\n                // Get scrolling speed\n                // Update lastScroll\n                scrollingSpeed = Math.abs(docScroll - lastScroll);\n                lastScroll = docScroll;\n\n                // update the current and interpolated values\n                for (var key in this.renderedStyles) {\n                    this.renderedStyles[key].current = this.renderedStyles[key].setValue();\n                    this.renderedStyles[key].previous = MathUtils.lerp(this.renderedStyles[key].previous, this.renderedStyles[key].current, this.renderedStyles[key].ease);\n                }\n                // and translate the scrollable element\n                this.layout();\n\n                // for every item\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var item = _step.value;\n\n                        // if the item is inside the viewport call it's render function\n                        // this will update item's styles, based on the document scroll value and the item's position on the viewport\n                        if (item.isVisible) {\n                            if (item.insideViewport) {\n                                item.render();\n                            } else {\n                                item.insideViewport = true;\n                                item.update();\n                            }\n                        } else {\n                            item.insideViewport = false;\n                        }\n                    }\n\n                    // loop..\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n\n                requestAnimationFrame(function () {\n                    return _this5.render();\n                });\n            }\n        }]);\n\n        return SmoothScroll;\n    }();\n\n    /***********************************/\n    /********** Preload stuff **********/\n\n    // Get the scroll position and update the lastScroll variable\n\n\n    getPageYScroll();\n    lastScroll = docScroll;\n    // Initialize the Smooth Scrolling\n    new SmoothScroll();\n    console.log(\"scrollTransform\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vLi4vLi4vc2NyaXB0cy9mcm9udGVuZC9zY3JvbGxUcmFuc2Zvcm1JbWFnZS9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9FOi9Xb3JrL2VoYWJhbmEyL2Fzc2V0cy9zY3JpcHRzL2Zyb250ZW5kL3Njcm9sbFRyYW5zZm9ybUltYWdlL2luZGV4LmpzP2E4OGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiogZGVtby5qc1xuKiBodHRwOi8vd3d3LmNvZHJvcHMuY29tXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiogXG4qIENvcHlyaWdodCAyMDE5LCBDb2Ryb3BzXG4qIGh0dHA6Ly93d3cuY29kcm9wcy5jb21cbiovXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG57XG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uc1xuICAgIHZhciBNYXRoVXRpbHMgPSB7XG4gICAgICAgIC8vIG1hcCBudW1iZXIgeCBmcm9tIHJhbmdlIFthLCBiXSB0byBbYywgZF1cbiAgICAgICAgbWFwOiBmdW5jdGlvbiBtYXAoeCwgYSwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuICh4IC0gYSkgKiAoZCAtIGMpIC8gKGIgLSBhKSArIGM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICAgIGxlcnA6IGZ1bmN0aW9uIGxlcnAoYSwgYiwgbikge1xuICAgICAgICAgICAgcmV0dXJuICgxIC0gbikgKiBhICsgbiAqIGI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFJhbmRvbSBmbG9hdFxuICAgICAgICBnZXRSYW5kb21GbG9hdDogZnVuY3Rpb24gZ2V0UmFuZG9tRmxvYXQobWluLCBtYXgpIHtcbiAgICAgICAgICAgIHJldHVybiAoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluKS50b0ZpeGVkKDIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGJvZHkgZWxlbWVudFxuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgdmlld3BvcnQgc2l6ZVxuICAgIHZhciB3aW5zaXplID0gdm9pZCAwO1xuICAgIHZhciBjYWxjV2luc2l6ZSA9IGZ1bmN0aW9uIGNhbGNXaW5zaXplKCkge1xuICAgICAgICByZXR1cm4gd2luc2l6ZSA9IHsgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLCBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCB9O1xuICAgIH07XG4gICAgY2FsY1dpbnNpemUoKTtcbiAgICAvLyBhbmQgcmVjYWxjdWxhdGUgb24gcmVzaXplXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGNhbGNXaW5zaXplKTtcblxuICAgIC8vIHNjcm9sbCBwb3NpdGlvblxuICAgIHZhciBkb2NTY3JvbGwgPSB2b2lkIDA7XG4gICAgLy8gZm9yIHNjcm9sbCBzcGVlZCBjYWxjdWxhdGlvblxuICAgIHZhciBsYXN0U2Nyb2xsID0gdm9pZCAwO1xuICAgIHZhciBzY3JvbGxpbmdTcGVlZCA9IDA7XG4gICAgLy8gc2Nyb2xsIHBvc2l0aW9uIHVwZGF0ZSBmdW5jdGlvblxuICAgIHZhciBnZXRQYWdlWVNjcm9sbCA9IGZ1bmN0aW9uIGdldFBhZ2VZU2Nyb2xsKCkge1xuICAgICAgICByZXR1cm4gZG9jU2Nyb2xsID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZ2V0UGFnZVlTY3JvbGwpO1xuXG4gICAgLy8gSXRlbVxuXG4gICAgdmFyIEl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEl0ZW0oZWwpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJdGVtKTtcblxuICAgICAgICAgICAgLy8gdGhlIC5pdGVtIGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuRE9NID0geyBlbDogZWwgfTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuRE9NKTtcbiAgICAgICAgICAgIC8vIHRoZSBpbm5lciBpbWFnZVxuICAgICAgICAgICAgdGhpcy5ET00uaW1hZ2UgPSB0aGlzLkRPTS5lbC5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcbiAgICAgICAgICAgIHRoaXMuRE9NLmltYWdlV3JhcHBlciA9IHRoaXMuRE9NLmltYWdlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAvL3RoaXMuRE9NLnRpdGxlID0gdGhpcy5ET00uZWwucXVlcnlTZWxlY3RvcignLmNvbnRlbnRfX2l0ZW0tdGl0bGUnKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWRTdHlsZXMgPSB7XG4gICAgICAgICAgICAgICAgLy8gaGVyZSB3ZSBkZWZpbmUgd2hpY2ggcHJvcGVydHkgd2lsbCBjaGFuZ2UgYXMgd2Ugc2Nyb2xsIHRoZSBwYWdlIGFuZCB0aGUgaXRlbSBpcyBpbnNpZGUgdGhlIHZpZXdwb3J0XG4gICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdpbGwgYmU6XG4gICAgICAgICAgICAgICAgLy8gLSBzY2FsaW5nIHRoZSBpbm5lciBpbWFnZVxuICAgICAgICAgICAgICAgIC8vIC0gdHJhbnNsYXRpbmcgdGhlIGl0ZW0ncyB0aXRsZVxuICAgICAgICAgICAgICAgIC8vIHdlIGludGVycG9sYXRlIGJldHdlZW4gdGhlIHByZXZpb3VzIGFuZCBjdXJyZW50IHZhbHVlIHRvIGFjaGlldmUgYSBzbW9vdGggZWZmZWN0XG4gICAgICAgICAgICAgICAgaW1hZ2VTY2FsZToge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcnBvbGF0ZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXM6IDAsXG4gICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudDogMCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYW1vdW50IHRvIGludGVycG9sYXRlXG4gICAgICAgICAgICAgICAgICAgIGVhc2U6IDAuMSxcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCB2YWx1ZSBzZXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvVmFsdWUgPSAxLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbVZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBNYXRoVXRpbHMubWFwKF90aGlzLnByb3BzLnRvcCAtIGRvY1Njcm9sbCwgd2luc2l6ZS5oZWlnaHQsIC0xICogX3RoaXMucHJvcHMuaGVpZ2h0LCBmcm9tVmFsdWUsIHRvVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHZhbCwgdG9WYWx1ZSksIGZyb21WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICB0aXRsZVRyYW5zbGF0aW9uWToge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91czogMCwgXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQ6IDAsIFxuICAgICAgICAgICAgICAgICAgICBlYXNlOiAwLjEsXG4gICAgICAgICAgICAgICAgICAgIGZyb21WYWx1ZTogTnVtYmVyKE1hdGhVdGlscy5nZXRSYW5kb21GbG9hdCgzMCw0MDApKSxcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb21WYWx1ZSA9IHRoaXMucmVuZGVyZWRTdHlsZXMudGl0bGVUcmFuc2xhdGlvblkuZnJvbVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9WYWx1ZSA9IC0xKmZyb21WYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IE1hdGhVdGlscy5tYXAodGhpcy5wcm9wcy50b3AgLSBkb2NTY3JvbGwsIHdpbnNpemUuaGVpZ2h0LCAtMSAqIHRoaXMucHJvcHMuaGVpZ2h0LCBmcm9tVmFsdWUsIHRvVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyb21WYWx1ZSA8IDAgPyBNYXRoLm1pbihNYXRoLm1heCh2YWwsIGZyb21WYWx1ZSksIHRvVmFsdWUpIDogTWF0aC5tYXgoTWF0aC5taW4odmFsLCBmcm9tVmFsdWUpLCB0b1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGdldHMgdGhlIGl0ZW0ncyBoZWlnaHQgYW5kIHRvcCAocmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50KVxuICAgICAgICAgICAgdGhpcy5nZXRTaXplKCk7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIGluaXRpYWwgdmFsdWVzXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgLy8gdXNlIHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlciBBUEkgdG8gY2hlY2sgd2hlbiB0aGUgZWxlbWVudCBpcyBpbnNpZGUgdGhlIHZpZXdwb3J0XG4gICAgICAgICAgICAvLyBvbmx5IHRoZW4gdGhlIGVsZW1lbnQgc3R5bGVzIHdpbGwgYmUgdXBkYXRlZFxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmlzVmlzaWJsZSA9IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKHRoaXMuRE9NLmVsKTtcbiAgICAgICAgICAgIC8vIGluaXQvYmluZCBldmVudHNcbiAgICAgICAgICAgIHRoaXMuaW5pdEV2ZW50cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2NyZWF0ZUNsYXNzKEl0ZW0sIFt7XG4gICAgICAgICAgICBrZXk6ICd1cGRhdGUnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXRzIHRoZSBpbml0aWFsIHZhbHVlIChubyBpbnRlcnBvbGF0aW9uKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnJlbmRlcmVkU3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZWRTdHlsZXNba2V5XS5jdXJyZW50ID0gdGhpcy5yZW5kZXJlZFN0eWxlc1trZXldLnByZXZpb3VzID0gdGhpcy5yZW5kZXJlZFN0eWxlc1trZXldLnNldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFwcGx5IGNoYW5nZXMvc3R5bGVzXG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5OiAnZ2V0U2l6ZScsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2l6ZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuRE9NLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0ncyBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgLy8gb2Zmc2V0IHRvcCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBkb2NTY3JvbGwgKyByZWN0LnRvcFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogJ2luaXRFdmVudHMnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRFdmVudHMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLnJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXk6ICdyZXNpemUnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXRzIHRoZSBpdGVtJ3MgaGVpZ2h0IGFuZCB0b3AgKHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudClcbiAgICAgICAgICAgICAgICB0aGlzLmdldFNpemUoKTtcbiAgICAgICAgICAgICAgICAvLyBvbiByZXNpemUgcmVzZXQgc2l6ZXMgYW5kIHVwZGF0ZSBzdHlsZXNcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXk6ICdyZW5kZXInLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGN1cnJlbnQgYW5kIGludGVycG9sYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5yZW5kZXJlZFN0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkU3R5bGVzW2tleV0uY3VycmVudCA9IHRoaXMucmVuZGVyZWRTdHlsZXNba2V5XS5zZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkU3R5bGVzW2tleV0ucHJldmlvdXMgPSBNYXRoVXRpbHMubGVycCh0aGlzLnJlbmRlcmVkU3R5bGVzW2tleV0ucHJldmlvdXMsIHRoaXMucmVuZGVyZWRTdHlsZXNba2V5XS5jdXJyZW50LCB0aGlzLnJlbmRlcmVkU3R5bGVzW2tleV0uZWFzZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYW5kIGFwcGx5IGNoYW5nZXNcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXk6ICdsYXlvdXQnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxheW91dCgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIiBzY2FsZSB0aGUgaW1hZ2UuLnxcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5ET00uaW1hZ2Uuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlM2QoJyArIHRoaXMucmVuZGVyZWRTdHlsZXMuaW1hZ2VTY2FsZS5wcmV2aW91cyArICcsJyArIHRoaXMucmVuZGVyZWRTdHlsZXMuaW1hZ2VTY2FsZS5wcmV2aW91cyArICcsMSknO1xuICAgICAgICAgICAgICAgIC8vIHRyYW5zbGF0ZSB0aGUgdGl0bGVcbiAgICAgICAgICAgICAgICAvLyAgdGhpcy5ET00udGl0bGUuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKDAsJHt0aGlzLnJlbmRlcmVkU3R5bGVzLnRpdGxlVHJhbnNsYXRpb25ZLnByZXZpb3VzfXB4LDApYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuXG4gICAgICAgIHJldHVybiBJdGVtO1xuICAgIH0oKTtcblxuICAgIC8vIFNtb290aFNjcm9sbFxuXG5cbiAgICB2YXIgU21vb3RoU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTbW9vdGhTY3JvbGwoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNtb290aFNjcm9sbCk7XG5cbiAgICAgICAgICAgIC8vIHRoZSA8bWFpbj4gZWxlbWVudFxuICAgICAgICAgICAgdGhpcy5ET00gPSB7IG1haW46IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKSB9O1xuICAgICAgICAgICAgLy8gdGhlIHNjcm9sbGFibGUgZWxlbWVudFxuICAgICAgICAgICAgLy8gd2UgdHJhbnNsYXRlIHRoaXMgZWxlbWVudCB3aGVuIHNjcm9sbGluZyAoeS1heGlzKVxuICAgICAgICAgICAgdGhpcy5ET00uc2Nyb2xsYWJsZSA9IHRoaXMuRE9NLm1haW4ucXVlcnlTZWxlY3RvcignbWFpbltkYXRhLXNjcm9sbF0nKTtcbiAgICAgICAgICAgIC8vIHRoZSBpdGVtcyBvbiB0aGUgcGFnZVxuICAgICAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5ET00uY29udGVudCA9IHRoaXMuRE9NLm1haW4ucXVlcnlTZWxlY3Rvcignc2VjdGlvbicpO1xuICAgICAgICAgICAgW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aGlzLkRPTS5jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5hbmltYXRlZC1pbWctY29udGFpbmVyJykpKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5pdGVtcy5wdXNoKG5ldyBJdGVtKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gaGVyZSB3ZSBkZWZpbmUgd2hpY2ggcHJvcGVydHkgd2lsbCBjaGFuZ2UgYXMgd2Ugc2Nyb2xsIHRoZSBwYWdlXG4gICAgICAgICAgICAvLyBpbiB0aGlzIGNhc2Ugd2Ugd2lsbCBiZSB0cmFuc2xhdGluZyBvbiB0aGUgeS1heGlzXG4gICAgICAgICAgICAvLyB3ZSBpbnRlcnBvbGF0ZSBiZXR3ZWVuIHRoZSBwcmV2aW91cyBhbmQgY3VycmVudCB2YWx1ZSB0byBhY2hpZXZlIHRoZSBzbW9vdGggc2Nyb2xsaW5nIGVmZmVjdFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZFN0eWxlcyA9IHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvblk6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJwb2xhdGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzOiAwLFxuICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFtb3VudCB0byBpbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICAgICAgICBlYXNlOiAwLjEsXG4gICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgdmFsdWUgc2V0dGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgY2FzZSB0aGUgdmFsdWUgb2YgdGhlIHRyYW5zbGF0aW9uIHdpbGwgYmUgdGhlIHNhbWUgbGlrZSB0aGUgZG9jdW1lbnQgc2Nyb2xsXG4gICAgICAgICAgICAgICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2NTY3JvbGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gc2V0IHRoZSBib2R5J3MgaGVpZ2h0XG4gICAgICAgICAgICB0aGlzLnNldFNpemUoKTtcbiAgICAgICAgICAgIC8vIHNldCB0aGUgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAvLyB0aGUgPG1haW4+IGVsZW1lbnQncyBzdHlsZSBuZWVkcyB0byBiZSBtb2RpZmllZFxuICAgICAgICAgICAgdGhpcy5zdHlsZSgpO1xuICAgICAgICAgICAgLy8gaW5pdC9iaW5kIGV2ZW50c1xuICAgICAgICAgICAgdGhpcy5pbml0RXZlbnRzKCk7XG4gICAgICAgICAgICAvLyBzdGFydCB0aGUgcmVuZGVyIGxvb3BcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5yZW5kZXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgX2NyZWF0ZUNsYXNzKFNtb290aFNjcm9sbCwgW3tcbiAgICAgICAgICAgIGtleTogJ3VwZGF0ZScsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIGluaXRpYWwgdmFsdWUgKG5vIGludGVycG9sYXRpb24pIC0gdHJhbnNsYXRlIHRoZSBzY3JvbGwgdmFsdWVcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5yZW5kZXJlZFN0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkU3R5bGVzW2tleV0uY3VycmVudCA9IHRoaXMucmVuZGVyZWRTdHlsZXNba2V5XS5wcmV2aW91cyA9IHRoaXMucmVuZGVyZWRTdHlsZXNba2V5XS5zZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0cmFuc2xhdGUgdGhlIHNjcm9sbGFibGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogJ2xheW91dCcsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGF5b3V0KCkge1xuICAgICAgICAgICAgICAgIHRoaXMuRE9NLnNjcm9sbGFibGUuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKDAsJyArIC0xICogdGhpcy5yZW5kZXJlZFN0eWxlcy50cmFuc2xhdGlvblkucHJldmlvdXMgKyAncHgsMCknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXk6ICdzZXRTaXplJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTaXplKCkge1xuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgaGVpZ2ggb2YgdGhlIGJvZHkgaW4gb3JkZXIgdG8ga2VlcCB0aGUgc2Nyb2xsYmFyIG9uIHRoZSBwYWdlXG4gICAgICAgICAgICAgICAgYm9keS5zdHlsZS5oZWlnaHQgPSB0aGlzLkRPTS5zY3JvbGxhYmxlLnNjcm9sbEhlaWdodCArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogJ3N0eWxlJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdHlsZSgpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgPG1haW4+IG5lZWRzIHRvIFwic3RpY2tcIiB0byB0aGUgc2NyZWVuIGFuZCBub3Qgc2Nyb2xsXG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoYXQgd2Ugc2V0IGl0IHRvIHBvc2l0aW9uIGZpeGVkIGFuZCBvdmVyZmxvdyBoaWRkZW4gXG4gICAgICAgICAgICAgICAgdGhpcy5ET00ubWFpbi5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgICAgICAgICAgdGhpcy5ET00ubWFpbi5zdHlsZS53aWR0aCA9IHRoaXMuRE9NLm1haW4uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICAgICAgICAgIHRoaXMuRE9NLm1haW4uc3R5bGUudG9wID0gdGhpcy5ET00ubWFpbi5zdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLkRPTS5tYWluLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogJ2luaXRFdmVudHMnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRFdmVudHMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAvLyBvbiByZXNpemUgcmVzZXQgdGhlIGJvZHkncyBoZWlnaHRcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM0LnNldFNpemUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5OiAncmVuZGVyJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgc2Nyb2xsaW5nIHNwZWVkXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGxhc3RTY3JvbGxcbiAgICAgICAgICAgICAgICBzY3JvbGxpbmdTcGVlZCA9IE1hdGguYWJzKGRvY1Njcm9sbCAtIGxhc3RTY3JvbGwpO1xuICAgICAgICAgICAgICAgIGxhc3RTY3JvbGwgPSBkb2NTY3JvbGw7XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGN1cnJlbnQgYW5kIGludGVycG9sYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5yZW5kZXJlZFN0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkU3R5bGVzW2tleV0uY3VycmVudCA9IHRoaXMucmVuZGVyZWRTdHlsZXNba2V5XS5zZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkU3R5bGVzW2tleV0ucHJldmlvdXMgPSBNYXRoVXRpbHMubGVycCh0aGlzLnJlbmRlcmVkU3R5bGVzW2tleV0ucHJldmlvdXMsIHRoaXMucmVuZGVyZWRTdHlsZXNba2V5XS5jdXJyZW50LCB0aGlzLnJlbmRlcmVkU3R5bGVzW2tleV0uZWFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFuZCB0cmFuc2xhdGUgdGhlIHNjcm9sbGFibGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBmb3IgZXZlcnkgaXRlbVxuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0aGlzLml0ZW1zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGl0ZW0gaXMgaW5zaWRlIHRoZSB2aWV3cG9ydCBjYWxsIGl0J3MgcmVuZGVyIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgdXBkYXRlIGl0ZW0ncyBzdHlsZXMsIGJhc2VkIG9uIHRoZSBkb2N1bWVudCBzY3JvbGwgdmFsdWUgYW5kIHRoZSBpdGVtJ3MgcG9zaXRpb24gb24gdGhlIHZpZXdwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5pbnNpZGVWaWV3cG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uaW5zaWRlVmlld3BvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5pbnNpZGVWaWV3cG9ydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vcC4uXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM1LnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XSk7XG5cbiAgICAgICAgcmV0dXJuIFNtb290aFNjcm9sbDtcbiAgICB9KCk7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgLyoqKioqKioqKiogUHJlbG9hZCBzdHVmZiAqKioqKioqKioqL1xuXG4gICAgLy8gR2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gYW5kIHVwZGF0ZSB0aGUgbGFzdFNjcm9sbCB2YXJpYWJsZVxuXG5cbiAgICBnZXRQYWdlWVNjcm9sbCgpO1xuICAgIGxhc3RTY3JvbGwgPSBkb2NTY3JvbGw7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgU21vb3RoIFNjcm9sbGluZ1xuICAgIG5ldyBTbW9vdGhTY3JvbGwoKTtcbiAgICBjb25zb2xlLmxvZyhcInNjcm9sbFRyYW5zZm9ybVwiKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBFOi9Xb3JrL2VoYWJhbmEyL2Fzc2V0cy9zY3JpcHRzL2Zyb250ZW5kL3Njcm9sbFRyYW5zZm9ybUltYWdlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuLi8uLi8uLi8uLi8uLi8uLi9zY3JpcHRzL2Zyb250ZW5kL3Njcm9sbFRyYW5zZm9ybUltYWdlL2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../../../../scripts/frontend/scrollTransformImage/index.js\n");

/***/ })

})